<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <!-- Mobile locked / best-effort no zoom -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Prompter (Stabil + Stage + Karaoke)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111827; --text:#e5e7eb; --muted:#94a3b8;
      --accent:#38bdf8; --border: rgba(148,163,184,.22); --radius:16px;
      --menuW: 360px;
      --karaokeSpoken: rgba(56,189,248,.45);
      --karaokeActiveBg: rgba(56,189,248,.22);
    }
    *{ box-sizing:border-box; }

    html{
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
      height: 100%;
    }
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:var(--bg);
      color:var(--text);
      height: 100%;
      overflow: hidden;
      touch-action: manipulation;
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
    }

    .stage{
      position:relative;
      height: 100dvh;
      width: 100vw;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .prompter{
      position: relative;
      height:100%;
      width:100%;
      overflow:auto;
      border:1px solid var(--border);
      border-radius: var(--radius);
      background: rgba(17,24,39,.22);
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
    }

    .marker{
      position: sticky;
      top: 45%;
      height: 0;
      border-top: 2px solid rgba(56,189,248,.55);
      margin: 0 1rem;
      pointer-events:none;
      z-index:2;
    }

    .content{
      padding: 16vh 5.5vw 24vh;
      font-size: 30px;
      line-height: 1.55;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Karaoke word styles */
    .k-word{
      padding: 0 .05em;
      border-radius: .35em;
      transition: background-color .08s linear, color .08s linear;
    }
    .k-spoken{
      color: rgba(229,231,235,.92);
      background: rgba(56,189,248,.08);
      box-shadow: 0 0 0 1px rgba(56,189,248,.06) inset;
    }
    .k-active{
      background: var(--karaokeActiveBg);
      box-shadow: 0 0 0 2px rgba(56,189,248,.25) inset;
      outline: 1px solid rgba(56,189,248,.35);
    }
    .k-active::after{
      content:"";
      display:inline-block;
      width:.2em;
    }

    /* Menu */
    .menu{
      position:absolute;
      top: 10px;
      left: 10px;
      bottom: 10px;
      width: min(var(--menuW), calc(100vw - 20px));
      background: rgba(17,24,39,.92);
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      z-index:10;
      transform: translateX(0);
      transition: transform .2s ease;
      max-height: calc(100% - 20px);
      overflow: hidden;
    }
    .menu.is-collapsed{ transform: translateX(calc(-100% - 16px)); }

    .menuHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding-bottom:8px;
      border-bottom:1px solid var(--border);
    }
    .title{ font-weight:700; font-size:14px; }
    .status{ color: var(--muted); font-size:12.5px; margin-top:4px; }

    .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }

    button, textarea, input{ font:inherit; color:var(--text); }
    button{
      border:1px solid var(--border);
      background: rgba(17,24,39,.95);
      padding: .55rem .75rem;
      border-radius: 14px;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
    }
    button.primary{ border-color: rgba(56,189,248,.45); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .pill{
      display:flex; align-items:center; gap:.5rem;
      padding:.4rem .6rem; border-radius:999px; border:1px solid var(--border);
      background: rgba(17,24,39,.75);
    }
    .pill label{ color:var(--muted); font-size:.85rem; white-space:nowrap; }
    .pill input[type="range"]{ width: 150px; }

    textarea{
      width:100%;
      min-height: 120px;
      background: rgba(17,24,39,.65);
      border:1px solid var(--border);
      border-radius: 14px;
      padding: .8rem;
      outline:none;
      overflow:auto;
      font-size: 16px; /* prevent mobile input zoom */
      touch-action: pan-y;
    }

    .handle{
      position:absolute;
      top: 14px;
      left: 14px;
      z-index: 20;
      display:none;
      gap: 8px;
    }
    .handle button{ border-radius:999px; padding:.55rem .7rem; }

    .hint{ color:var(--muted); font-size:12.5px; line-height:1.35; }

    /* Listening indicator */
    .dot{
      width: 10px; height: 10px; border-radius: 999px;
      background: rgba(148,163,184,.35);
      display:inline-block;
      margin-right: 6px;
      vertical-align: middle;
    }
    .dot.live{
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(56,189,248,.15);
      animation: pulse 1.1s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform: scale(1); opacity: 1; }
      50%{ transform: scale(1.15); opacity: .75; }
    }

    .stageHUD{
      position:absolute;
      right: 14px;
      bottom: 14px;
      z-index: 50;
      display:none;
      gap: 10px;
      padding: 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(17,24,39,.88);
      touch-action: manipulation;
    }
    .stageHUD button{
      width: 54px;
      height: 54px;
      border-radius: 999px;
      padding: 0;
      font-size: 18px;
    }

    .rotateWarn{
      position:absolute;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 24px;
      background: rgba(0,0,0,.72);
      z-index: 100;
      color: var(--text);
      font-size: 18px;
    }
    @media (orientation: landscape){
      .rotateWarn{ display:flex; }
    }
  </style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="rotateWarn">Bitte Smartphone hochkant halten üì±‚ÜïÔ∏è</div>

    <div class="handle" id="handle">
      <button id="btnMenuOpen" class="primary">‚ò∞</button>
      <button id="btnFullscreen2">‚õ∂</button>
    </div>

    <aside class="menu" id="menu">
      <div class="menuHeader">
        <div>
          <div class="title">
            <span class="dot" id="dot"></span>
            Prompter
          </div>
          <div class="status" id="status">Bereit. Text einf√ºgen ‚Üí Voice-Follow starten.</div>
        </div>
        <button id="btnMenuCollapse" title="Men√º einklappen">‚ü®</button>
      </div>

      <div class="row">
        <button id="btnStart" class="primary">üéôÔ∏è Voice-Follow</button>
        <button id="btnStop">‚èπÔ∏è Stop</button>
        <button id="btnResync">üîÅ Re-Sync</button>
      </div>

      <div class="row">
        <button id="btnScroll" class="primary">‚ñ∂Ô∏è Auto-Scroll</button>
        <button id="btnScrollStop">‚è∏Ô∏è Pause</button>
        <button id="btnFullscreen" class="primary">‚õ∂ Vollbild</button>
        <button id="btnStage" class="primary">üé¨ Stage</button>
      </div>

      <div class="row">
        <span class="pill">
          <label>Speed</label>
          <input id="speed" type="range" min="0" max="100" value="22" />
        </span>
        <span class="pill">
          <label>Schrift</label>
          <input id="font" type="range" min="18" max="54" value="30" />
        </span>
      </div>

      <div class="row">
        <span class="pill">
          <label><input id="snap" type="checkbox" checked /> Jump-to-match</label>
        </span>
        <span class="pill">
          <label><input id="stable" type="checkbox" checked /> Stabil Mode</label>
        </span>
        <span class="pill">
          <label><input id="karaoke" type="checkbox" checked /> Karaoke</label>
        </span>
      </div>

      <textarea id="text" placeholder="Hier deinen Vortragstext einf√ºgen‚Ä¶"></textarea>
      <div class="hint">Stabil Mode startet neu, falls Chrome stoppt. Karaoke markiert deinen aktuellen Wort-Stand.</div>
    </aside>

    <div class="stageHUD" id="stageHUD" aria-label="Stage Controls">
      <button id="hudVoice" class="primary" title="Voice an/aus">üéô</button>
      <button id="hudPause" title="Auto-Scroll an/aus">‚è∏</button>
      <button id="hudFull" class="primary" title="Vollbild">‚õ∂</button>
      <button id="hudMenu" title="Men√º">‚ò∞</button>
    </div>

    <main class="prompter" id="prompter" aria-label="Teleprompter">
      <div class="marker"></div>
      <div class="content" id="content"></div>
    </main>
  </div>

<script>
(() => {
  // --- Best-effort block pinch/double-tap zoom ---
  document.addEventListener('gesturestart', (e) => e.preventDefault?.(), { passive: false });
  document.addEventListener('gesturechange', (e) => e.preventDefault?.(), { passive: false });
  document.addEventListener('gestureend', (e) => e.preventDefault?.(), { passive: false });

  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  // Elements
  const menu = document.getElementById('menu');
  const handle = document.getElementById('handle');
  const elText = document.getElementById('text');
  const elContent = document.getElementById('content');
  const elPrompter = document.getElementById('prompter');
  const elStatus = document.getElementById('status');
  const dot = document.getElementById('dot');

  const elSpeed = document.getElementById('speed');
  const elFont  = document.getElementById('font');
  const elSnap  = document.getElementById('snap');
  const elStable = document.getElementById('stable');
  const elKaraoke = document.getElementById('karaoke');

  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const btnScroll = document.getElementById('btnScroll');
  const btnScrollStop = document.getElementById('btnScrollStop');
  const btnResync = document.getElementById('btnResync');

  const btnFullscreen = document.getElementById('btnFullscreen');
  const btnFullscreen2 = document.getElementById('btnFullscreen2');

  const btnMenuCollapse = document.getElementById('btnMenuCollapse');
  const btnMenuOpen = document.getElementById('btnMenuOpen');

  const btnStage = document.getElementById('btnStage');
  const stageHUD = document.getElementById('stageHUD');
  const hudVoice = document.getElementById('hudVoice');
  const hudPause = document.getElementById('hudPause');
  const hudFull  = document.getElementById('hudFull');
  const hudMenu  = document.getElementById('hudMenu');

  // Helpers
  function setStatus(msg){ elStatus.textContent = msg; }
  function setListening(on){ dot.classList.toggle('live', !!on); }

  function applyFont(){ elContent.style.fontSize = elFont.value + "px"; }
  elFont.addEventListener('input', applyFont);
  applyFont();

  // Menu collapse / expand
  function collapseMenu(){
    menu.classList.add('is-collapsed');
    handle.style.display = 'flex';
  }
  function openMenu(){
    menu.classList.remove('is-collapsed');
    handle.style.display = 'none';
  }
  btnMenuCollapse.addEventListener('click', collapseMenu);
  btnMenuOpen.addEventListener('click', openMenu);

  // -------- Karaoke renderer (word-level mapping) --------
  // We'll build spans for words and track each span's normalized index range
  let wordMap = [];          // {start,end, el}
  let activeWordIdx = -1;    // index into wordMap
  let lastSpokenUpTo = -1;   // last "spoken" word index to avoid full repaint

  function normalize(s){
    return (s || "")
      .toLowerCase()
      .replace(/[^a-z0-9√§√∂√º√ü\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  function isWordChar(ch){
    // german-ish word chars
    return /[A-Za-z0-9√Ñ√ñ√ú√§√∂√º√ü]/.test(ch);
  }

  function clearKaraokeClasses(fromIdx=0){
    for (let i = fromIdx; i < wordMap.length; i++){
      const el = wordMap[i].el;
      el.classList.remove('k-spoken','k-active');
    }
    activeWordIdx = -1;
    lastSpokenUpTo = -1;
  }

  function renderText(){
    const raw = elText.value || "";
    wordMap = [];
    activeWordIdx = -1;
    lastSpokenUpTo = -1;

    // If karaoke off -> plain text (fast)
    if (!elKaraoke.checked){
      elContent.textContent = raw || "‚¨ÖÔ∏è Text einf√ºgen‚Ä¶";
      return;
    }

    // Karaoke ON -> build DOM with word spans
    elContent.innerHTML = "";
    if (!raw){
      elContent.textContent = "‚¨ÖÔ∏è Text einf√ºgen‚Ä¶";
      return;
    }

    const frag = document.createDocumentFragment();

    let normPos = 0;
    let i = 0;

    // split into paragraphs by newline for better layout
    const lines = raw.split(/\n/);
    for (let li = 0; li < lines.length; li++){
      const line = lines[li];
      const p = document.createElement('div');
      // keep spacing similar to pre-wrap
      p.style.whiteSpace = "pre-wrap";

      let j = 0;
      while (j < line.length){
        const ch = line[j];

        if (isWordChar(ch)){
          // read word
          let w = "";
          const startNorm = normPos;
          while (j < line.length && isWordChar(line[j])){
            w += line[j];
            j++;
          }
          // normalized word length counts as itself
          const normWord = normalize(w);
          const endNorm = startNorm + (normWord ? normWord.length : 0);

          // create span
          const span = document.createElement('span');
          span.className = "k-word";
          span.textContent = w;

          // store mapping (only if normWord exists)
          if (normWord){
            wordMap.push({ start: startNorm, end: endNorm, el: span });
            normPos = endNorm;
          }

          p.appendChild(span);
          continue;
        }

        // whitespace/punctuation: render as-is, update normPos appropriately
        // normalize() turns punctuation into spaces; we count *one* space for any whitespace block
        if (/\s/.test(ch)){
          // keep original whitespace
          let ws = "";
          while (j < line.length && /\s/.test(line[j])){
            ws += line[j];
            j++;
          }
          p.appendChild(document.createTextNode(ws));
          // normalized collapse: ensure single space if there are already words
          if (wordMap.length > 0){
            normPos += 1;
          }
          continue;
        } else {
          // punctuation -> render, in normalized becomes space
          p.appendChild(document.createTextNode(ch));
          j++;
          if (wordMap.length > 0){
            normPos += 1;
          }
          continue;
        }
      }

      frag.appendChild(p);
      if (li !== lines.length - 1){
        frag.appendChild(document.createTextNode("\n"));
        if (wordMap.length > 0) normPos += 1; // newline -> space-ish in normalize
      }
    }

    elContent.appendChild(frag);
  }

  elText.addEventListener('input', renderText);
  elKaraoke.addEventListener('change', () => {
    renderText();
  });

  // initial render
  renderText();

  // Binary search for word containing normalized index
  function findWordByNormIndex(idx){
    if (!wordMap.length) return -1;
    let lo = 0, hi = wordMap.length - 1;
    while (lo <= hi){
      const mid = (lo + hi) >> 1;
      const w = wordMap[mid];
      if (idx < w.start) hi = mid - 1;
      else if (idx >= w.end) lo = mid + 1;
      else return mid;
    }
    // if not inside a word, return nearest previous
    return Math.max(0, Math.min(wordMap.length - 1, hi));
  }

  function scrollWordIntoView(wordIdx){
    if (wordIdx < 0 || wordIdx >= wordMap.length) return;
    const wEl = wordMap[wordIdx].el;
    if (!wEl?.getBoundingClientRect) return;

    const r = wEl.getBoundingClientRect();
    const pr = elPrompter.getBoundingClientRect();
    const current = elPrompter.scrollTop;

    const relTop = (r.top - pr.top) + current;
    const target = relTop - (elPrompter.clientHeight * 0.40);
    elPrompter.scrollTop = Math.max(0, target);
  }

  function updateKaraoke(matchIdxNorm){
    if (!elKaraoke.checked || !wordMap.length) return;

    const wIdx = findWordByNormIndex(matchIdxNorm);
    if (wIdx === activeWordIdx) return;

    // remove old active
    if (activeWordIdx >= 0 && activeWordIdx < wordMap.length){
      wordMap[activeWordIdx].el.classList.remove('k-active');
    }

    activeWordIdx = wIdx;

    // mark spoken up to active
    // only update delta for performance
    const newSpokenUpTo = Math.max(-1, activeWordIdx - 1);

    if (newSpokenUpTo > lastSpokenUpTo){
      for (let i = lastSpokenUpTo + 1; i <= newSpokenUpTo; i++){
        if (i >= 0 && i < wordMap.length) wordMap[i].el.classList.add('k-spoken');
      }
    } else if (newSpokenUpTo < lastSpokenUpTo){
      // if it jumped backwards, clear and repaint
      clearKaraokeClasses(0);
      for (let i = 0; i <= newSpokenUpTo; i++){
        if (i >= 0 && i < wordMap.length) wordMap[i].el.classList.add('k-spoken');
      }
    }
    lastSpokenUpTo = newSpokenUpTo;

    // set active
    if (activeWordIdx >= 0 && activeWordIdx < wordMap.length){
      wordMap[activeWordIdx].el.classList.add('k-active');
      // scroll to active (karaoke view is more accurate than ratio scroll)
      scrollWordIntoView(activeWordIdx);
    }
  }

  // Auto-scroll
  let raf = null;
  let autoScrollOn = false;

  function tick(){
    if (!autoScrollOn) return;
    const v = Number(elSpeed.value);
    const pxPerSec = (v * v) / 60;
    elPrompter.scrollTop += pxPerSec / 60;
    raf = requestAnimationFrame(tick);
  }

  function startAutoScroll(){
    autoScrollOn = true;
    if (!raf) raf = requestAnimationFrame(tick);
    setStatus("Auto-Scroll l√§uft.");
  }
  function stopAutoScroll(){
    autoScrollOn = false;
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    setStatus("Auto-Scroll pausiert.");
  }

  btnScroll.addEventListener('click', startAutoScroll);
  btnScrollStop.addEventListener('click', stopAutoScroll);

  // Voice-follow (stabil)
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  let rec = null;

  let shouldRestart = false;
  let restartTimer = null;
  let restartDelay = 350;
  const restartDelayMax = 5000;

  let lastTranscript = "";
  let lastMatchIndex = 0;
  let lastHeardAt = 0;

  function findBestMatchIndex(textNorm, spoken, fromIdx){
    const sp = normalize(spoken);
    if (!textNorm || !sp) return -1;

    const words = sp.split(" ").filter(Boolean);
    const anchor = words.slice(-6).join(" ");
    const a = anchor.length >= 8 ? anchor : sp;

    const start = Math.max(0, fromIdx - 800);
    const end = Math.min(textNorm.length, fromIdx + 3500);
    const slice = textNorm.slice(start, end);

    const local = slice.indexOf(a);
    if (local !== -1) return start + local;

    for (let k = 5; k >= 3; k--){
      const t = words.slice(-k).join(" ");
      if (t.length < 8) continue;
      const l = slice.indexOf(t);
      if (l !== -1) return start + l;
    }
    return textNorm.indexOf(a);
  }

  function clearRestartTimer(){
    if (restartTimer) clearTimeout(restartTimer);
    restartTimer = null;
  }

  function scheduleRestart(reason){
    clearRestartTimer();
    if (!shouldRestart || !elStable.checked) return;

    setListening(false);
    setStatus(`‚ö†Ô∏è Voice-Follow beendet (${reason}) ‚Äì starte neu‚Ä¶`);

    restartTimer = setTimeout(() => {
      restartTimer = null;
      tryStartRecognition();
    }, restartDelay);

    restartDelay = Math.min(restartDelayMax, Math.floor(restartDelay * 1.35));
  }

  function resetBackoff(){ restartDelay = 350; }

  function buildRecognition(){
    const r = new SpeechRecognition();
    r.lang = "de-DE";
    r.continuous = true;
    r.interimResults = true;
    return r;
  }

  function tryStartRecognition(){
    if (!SpeechRecognition){
      setStatus("‚ùå SpeechRecognition nicht verf√ºgbar. √ñffne in Chrome.");
      return;
    }
    if (!shouldRestart) return;

    if (rec){
      try { rec.onend = null; rec.onerror = null; rec.onresult = null; } catch(e){}
      rec = null;
    }

    rec = buildRecognition();

    rec.onstart = () => {
      resetBackoff();
      setListening(true);
      setStatus("üéôÔ∏è Voice-Follow aktiv (Stabil Mode).");
    };

    rec.onerror = (e) => {
      const err = (e && e.error) ? e.error : "unknown";
      if (err === "not-allowed" || err === "service-not-allowed"){
        shouldRestart = false;
        setListening(false);
        setStatus("‚ùå Mikro nicht erlaubt. Chrome ‚Üí Website-Einstellungen ‚Üí Mikro erlauben.");
        try { rec.stop(); } catch(_) {}
        rec = null;
        return;
      }
      scheduleRestart(err);
    };

    rec.onend = () => scheduleRestart("end");

    rec.onresult = (ev) => {
      let interim = "", finalTxt = "";
      for (let i = ev.resultIndex; i < ev.results.length; i++){
        const rr = ev.results[i];
        if (rr.isFinal) finalTxt += rr[0].transcript + " ";
        else interim += rr[0].transcript + " ";
      }
      const combined = (finalTxt + interim).trim();
      if (!combined || combined === lastTranscript) return;

      lastTranscript = combined;
      lastHeardAt = Date.now();

      const rawText = elText.value || "";
      const textNorm = normalize(rawText);

      const matchIdx = findBestMatchIndex(textNorm, combined, lastMatchIndex);
      if (matchIdx >= 0){
        lastMatchIndex = matchIdx;

        // Karaoke highlight + auto-scroll to active word
        updateKaraoke(matchIdx);

        setStatus("üéôÔ∏è synchronisiert.");
      } else {
        setStatus("üéôÔ∏è h√∂re dich, finde die Stelle nicht ‚Äì Re-Sync.");
      }
    };

    try{ rec.start(); }
    catch(e){ scheduleRestart("start-failed"); }
  }

  function startRec(){
    if (!SpeechRecognition){
      setStatus("‚ùå SpeechRecognition nicht verf√ºgbar. √ñffne in Chrome.");
      return;
    }
    shouldRestart = true;
    clearRestartTimer();
    resetBackoff();
    setStatus("üéôÔ∏è Starte Voice-Follow‚Ä¶");
    tryStartRecognition();
  }

  function stopRec(){
    shouldRestart = false;
    clearRestartTimer();
    setListening(false);
    setStatus("‚èπÔ∏è Voice-Follow gestoppt.");
    if (rec){
      try { rec.stop(); } catch(e){}
      rec = null;
    }
  }

  // Heartbeat (avoid dead states)
  setInterval(() => {
    if (!shouldRestart || !elStable.checked) return;
    if (!rec) return;
    const now = Date.now();
    if (lastHeardAt && (now - lastHeardAt) > 35000){
      scheduleRestart("idle");
      try { rec.stop(); } catch(e){}
      rec = null;
      lastHeardAt = now;
    }
  }, 5000);

  btnStart.addEventListener('click', startRec);
  btnStop.addEventListener('click', stopRec);

  btnResync.addEventListener('click', () => {
    const raw = elText.value || "";
    const ratio = elPrompter.scrollTop / Math.max(1, (elPrompter.scrollHeight - elPrompter.clientHeight));
    lastMatchIndex = Math.floor(ratio * normalize(raw).length);
    setStatus("üîÅ Re-Sync gesetzt.");

    // also reset karaoke to new scroll position (best-effort)
    if (elKaraoke.checked){
      updateKaraoke(lastMatchIndex);
    }
  });

  // Fullscreen
  async function toggleFullscreen(){
    try{
      if (!document.fullscreenElement){
        await document.documentElement.requestFullscreen();
        setStatus("‚õ∂ Vollbild aktiv.");
      } else {
        await document.exitFullscreen();
        setStatus("Vollbild beendet.");
      }
    } catch(e){
      setStatus("‚ö†Ô∏è Vollbild nicht m√∂glich: " + e.message);
    }
  }
  btnFullscreen.addEventListener('click', toggleFullscreen);
  btnFullscreen2.addEventListener('click', toggleFullscreen);

  // Stage Mode
  let stageMode = false;

  function setStageMode(on){
    stageMode = !!on;
    stageHUD.style.display = stageMode ? 'flex' : 'none';
    if (stageMode){
      collapseMenu();
      setStatus("üé¨ Stage Mode aktiv.");
    } else {
      openMenu();
      setStatus("Stage Mode aus.");
    }
  }
  btnStage.addEventListener('click', () => setStageMode(!stageMode));

  // HUD actions
  hudVoice.addEventListener('click', () => {
    if (shouldRestart) stopRec();
    else startRec();
  });

  hudPause.addEventListener('click', () => {
    if (autoScrollOn) stopAutoScroll();
    else startAutoScroll();
  });

  hudFull.addEventListener('click', () => toggleFullscreen());

  hudMenu.addEventListener('click', () => {
    if (menu.classList.contains('is-collapsed')) openMenu();
    else collapseMenu();
  });

  // Tap on prompter toggles menu in Stage Mode
  elPrompter.addEventListener('click', () => {
    if (!stageMode) return;
    if (menu.classList.contains('is-collapsed')) openMenu();
    else collapseMenu();
  });

})();
</script>
</body>
</html>
